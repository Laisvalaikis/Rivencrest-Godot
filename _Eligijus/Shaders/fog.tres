[gd_resource type="Shader" format=3 uid="uid://c8ydwtwb6a8ni"]

[resource]
code = "shader_type canvas_item;
render_mode blend_mix;

uniform sampler2D NOISE_PATTERN : repeat_enable;

// Amount of detail.
uniform int octaves = 4;

// Opacity of the output fog.
uniform float starting_amplitude: hint_range(0.0, 0.5) = 0.5;

// Rate of pattern within the fog.
uniform float starting_frequency = 1.0;

// Shift towards transparency (clamped) for sparser fog.
uniform float shift: hint_range(-1.0, 0.0) = -0.2;

// White cut off
uniform float white_cutoff: hint_range(0.0, 1.0) = 0.999;

uniform float scale: hint_range(0.0, 1.0) = 0.9;

// Direction and speed of travel.
uniform vec2 velocity = vec2(1.0, 1.0);

uniform vec2 fog_position = vec2(0.0, 0.0);

uniform vec2 fog_size = vec2(0.1, 0.1);

uniform vec2 fog_border_size = vec2(0.0, 0.0);

uniform vec2 square_size = vec2(0.0331, 0.0331);

uniform int fog_position_array_size = 0;

uniform vec2 fog_position_array[300];

uniform vec2 fog_player_position_array[300];

uniform vec2 fog_max_position = vec2(0.0, 0.0);

uniform int fog_player_position_array_size = 0;
// Color of the fog.
uniform vec4 fog_color = vec4(0.0, 0.0, 0.0, 1.0);

float rand(vec2 uv) {
	float amplitude = starting_amplitude;
	float frequency = starting_frequency;
	float output = 0.0;
	for (int i = 0; i < octaves; i++) {
		output += texture(NOISE_PATTERN, uv * frequency).x * amplitude;
		amplitude /= 2.0;
		frequency *= 2.0;
	}
	return clamp(output + shift, 0.0, 1.0);
}

float truncate(float value) {
    // This will truncate the value, removing the fractional part
    return sign(value) * floor(abs(value));
}

bool Top(float value)
{
	if(truncate(mod((value/10000.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool Bottom(float value)
{
	if(truncate(mod((value/1000.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool Right(float value)
{
	if(truncate(mod((value/100.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool Left(float value)
{
	if(truncate(mod((value/10.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool None(float value)
{
	if(truncate(mod((value/10.0), 1.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool EveryCorner(float value)
{
	if(value < 0.000001)
	{
		return true;
	}
	return false;
}

float fogDistanceGraph(float alpha)
{
	return pow(alpha, 1.0/2.0);
}

vec4 rectanbleBorder(vec2 uv, vec4 color, vec2 start_position, vec2 position, vec2 end_position, vec2 size)
{
    //vec4 color = vec4(0,0,0,1);
	vec4 tempColor = color;
	if ((uv.x > position.x - size.x / 2.0) && (uv.x < position.x + size.x / 2.0)
		&& (uv.y > position.y - size.y / 2.0) && (uv.y < position.y + size.y / 2.0)) {
		
		//color = vec4(0,0,0,0);
		//tempColor = color;
		for(int i = 0; i < fog_player_position_array_size; i++)
		{
			float starting_point = 0.0;
			float current_point = distance(fog_player_position_array[i], position);
			float last_point = distance(fog_player_position_array[i], end_position);
			float current_position = ((current_point - starting_point) / (last_point - starting_point));
		    current_position = abs(current_position);
			current_position = clamp(current_position, 0.0, 1.0);
			float alpha = fogDistanceGraph(current_position) * tempColor.a;
			if(tempColor.a > alpha)
			{
				tempColor.a = alpha;
			}
			//tempColor.a = alpha;
		}
		
		//float starting_point = 0.0;
		//float current_point = distance(fog_player_position_array[2], position);
		//float last_point = distance(fog_player_position_array[2], end_position);
		//float current_position = ((current_point - starting_point) / (last_point - starting_point));
	    //current_position = abs(current_position);
		//current_position = clamp(current_position, 0.0, 1.0);
		//float alpha = fogDistanceGraph(current_position) * tempColor.a;
		//tempColor.a = alpha;
		
	}
	return tempColor;
}

void fragment() {
	vec4 mainTexture = texture(TEXTURE, UV);
	vec2 motion = vec2(rand(UV + TIME * starting_frequency * velocity));
	vec4 negative_fog_value = vec4(1.0 - fog_color.rgb, fog_color.a);
	vec4 color = mix(mainTexture, fog_color, rand(UV + motion));
	//vec3 fog_position_array[10];
	// top, bottom, right, left
	//fog_position_array[0] = vec3(0.55, 0.55, 1000.0);
	//fog_position_array[1] = vec3(0.583, 0.516, 1000.0);
	//COLOR = color;
	//float real_alfa_cutoff = 1.0 - white_cutoff;
	//if(color.r * color.g * color.b > real_alfa_cutoff)
	//{
		////COLOR.rgb = vec3(0,0,0);
		//color.a = 0.0;
	//}
	for (int i = 0; i < fog_position_array_size; i++) 
	{
		color = rectanbleBorder(UV, color, fog_position_array[1].rg, fog_position_array[i].rg, fog_max_position, square_size);
	}
	
	COLOR = color;
}
"
