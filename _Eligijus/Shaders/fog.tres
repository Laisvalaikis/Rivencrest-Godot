[gd_resource type="Shader" format=3 uid="uid://c8ydwtwb6a8ni"]

[resource]
code = "shader_type canvas_item;
render_mode blend_mix;

uniform sampler2D NOISE_PATTERN : repeat_enable;

// Amount of detail.
uniform int octaves = 4;

// Opacity of the output fog.
uniform float starting_amplitude: hint_range(0.0, 0.5) = 0.5;

// Rate of pattern within the fog.
uniform float starting_frequency = 1.0;

// Shift towards transparency (clamped) for sparser fog.
uniform float shift: hint_range(-1.0, 0.0) = -0.2;

// White cut off
uniform float white_cutoff: hint_range(0.0, 1.0) = 0.999;

uniform float scale: hint_range(0.0, 1.0) = 0.9;

// Direction and speed of travel.
uniform vec2 velocity = vec2(1.0, 1.0);

uniform vec2 fog_position = vec2(0.0, 0.0);

uniform vec2 fog_size = vec2(0.1, 0.1);

uniform vec2 fog_border_size = vec2(0.0, 0.0);

uniform vec2 square_size = vec2(0.0331, 0.0331);

uniform int fog_position_array_size = 0;

uniform vec3 fog_position_array[300];
// Color of the fog.
uniform vec4 fog_color = vec4(0.0, 0.0, 0.0, 1.0);

float rand(vec2 uv) {
	float amplitude = starting_amplitude;
	float frequency = starting_frequency;
	float output = 0.0;
	for (int i = 0; i < octaves; i++) {
		output += texture(NOISE_PATTERN, uv * frequency).x * amplitude;
		amplitude /= 2.0;
		frequency *= 2.0;
	}
	return clamp(output + shift, 0.0, 1.0);
}

float truncate(float value) {
    // This will truncate the value, removing the fractional part
    return sign(value) * floor(abs(value));
}

bool Top(float value)
{
	if(truncate(mod((value/10000.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool Bottom(float value)
{
	if(truncate(mod((value/1000.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool Right(float value)
{
	if(truncate(mod((value/100.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool Left(float value)
{
	if(truncate(mod((value/10.0), 10.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool None(float value)
{
	if(truncate(mod((value/10.0), 1.0)) == 1.0)
	{
		return true;
	}
	return false;
}

bool EveryCorner(float value)
{
	if(value < 0.000001)
	{
		return true;
	}
	return false;
}

vec4 sideGradient(vec4 color, float side)
{
		float gradient = 1.0 - side * 2.0;
    	gradient = clamp(gradient, 0.0, 1.0);
		color = vec4(vec3(gradient), color.a);
		color.a = color.a - color.r * color.g * color.b * 100.0;
		return color;
}

vec4 rectanbleBorder(vec2 uv, vec4 color, vec2 position, float side, vec2 size, float border_size)
{
    //vec4 color = vec4(0,0,0,1);
	vec4 tempColor = color;
	if ((uv.x > position.x - size.x / 2.0) && (uv.x < position.x + size.x / 2.0)
		&& (uv.y > position.y - size.y / 2.0) && (uv.y < position.y + size.y / 2.0)) {
		
		color = vec4(0,0,0,0);
		tempColor = color;
		//vec2 maxBoundrie = position + size / 2.0 * 4.0;
		//vec2 minBoundrie = position - size / 2.0;
		//
		//vec2 boundary_size = maxBoundrie - minBoundrie;
		//vec2 normalized_uv = (uv - minBoundrie) / boundary_size;
		//vec2 dist_from_center = abs(normalized_uv - vec2(0.5, 0.5));
		//
		//float grad_distance = max(dist_from_center.x, dist_from_center.y);
		//
		//float gradient = 1.0 - grad_distance * 2.0;
    	//gradient = clamp(gradient, 0.0, 1.0);
		//tempColor = vec4(vec3(gradient), tempColor.a);
		//tempColor.a = tempColor.a - tempColor.r * tempColor.g * tempColor.b;
		
		//if(!EveryCorner(side))
		//{
			//if(!None(side))
			//{
				//if(uv.y > position.y - size.y / 2.0 && uv.y < position.y && Top(side) &&
					//(uv.x > position.x - size.x / 2.0 + border_size) && (uv.x < position.x + size.x / 2.0 - border_size)) // top
				//{
					//tempColor.a = 0.0;
				//}
				//
				//if(uv.y > position.y && uv.y < position.y + size.y / 2.0 && Bottom(side) &&
					//(uv.x > position.x - size.x / 2.0 + border_size) && (uv.x < position.x + size.x / 2.0 - border_size)) // bottom
				//{
					//tempColor.a = 0.0;
				//}
				//
				//if(uv.x > position.x - size.x / 2.0 && uv.x < position.x - border_size && Left(side) &&
					//(uv.y > position.y - size.y / 2.0 + border_size) && (uv.y < position.y + size.y / 2.0 - border_size)) // left
				//{
					//tempColor.a = 0.0;
				//}
				//
				//if(uv.x > position.x + border_size && uv.x < position.x + size.x / 2.0 && Right(side) &&
					//(uv.y > position.y - size.y / 2.0 + border_size) && (uv.y < position.y + size.y / 2.0 - border_size)) // right
				//{
					//tempColor.a = 0.0;
				//}
			//
				//if(uv.y > position.y - size.y / 2.0 && uv.y < position.y - size.y / 2.0 + border_size &&
					//(uv.x > position.x - size.x / 2.0) && (uv.x < position.x - size.x / 2.0 + border_size)) // top left
				//{
					//if(Top(side) && Left(side))
					//{
						//tempColor.a = 0.0;
					//}
					//else if(Left(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.y);
					//}
					//else if(Top(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.x);
					//}
				//}
				//
				//if(uv.y > position.y - size.y / 2.0 && uv.y < position.y - size.y / 2.0 + border_size &&
					//(uv.x > position.x + size.x / 2.0 - border_size) && (uv.x < position.x + size.x / 2.0)) // top right
				//{
					//if(Right(side) && Top(side))
					//{
						//tempColor.a = 0.0;
					//}
					//else if(Right(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.y);
					//}
					//else if(Top(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.x);
					//}
				//}
				//
				//if(uv.y > position.y + size.y / 2.0 - border_size && uv.y < position.y + size.y / 2.0 &&
					//(uv.x > position.x - size.x / 2.0) && (uv.x < position.x - size.x / 2.0 + border_size)) // bottom left
				//{
					//if(Left(side) && Bottom(side))
					//{
						//tempColor.a = 0.0;
					//}
					//else if(Left(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.y);
					//}
					//else if(Bottom(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.x);
					//}
				//}
				//
				//if(uv.y > position.y + size.y / 2.0 - border_size && uv.y < position.y + size.y / 2.0 &&
					//(uv.x > position.x + size.x / 2.0 - border_size) && (uv.x < position.x + size.x / 2.0)) // bottom right
				//{
					//if(Right(side) && Bottom(side))
					//{
						//tempColor.a = 0.0;
					//}
					//if(Right(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.y);
					//}
					//else if(Bottom(side))
					//{
						//tempColor = sideGradient(color, dist_from_center.x);
					//}
				//}
			//}
			//else
			//{
				//tempColor.a = 0.0;
			//}
		//}
	}
	return tempColor;
}

void fragment() {
	vec4 mainTexture = texture(TEXTURE, UV);
	vec2 motion = vec2(rand(UV + TIME * starting_frequency * velocity));
	vec4 negative_fog_value = vec4(1.0 - fog_color.rgb, fog_color.a);
	vec4 color = mix(mainTexture, fog_color, rand(UV + motion));
	//vec3 fog_position_array[10];
	// top, bottom, right, left
	//fog_position_array[0] = vec3(0.55, 0.55, 1000.0);
	//fog_position_array[1] = vec3(0.583, 0.516, 1000.0);
	COLOR = color;
	float real_alfa_cutoff = 1.0 - white_cutoff;
	//if(color.r * color.g * color.b > real_alfa_cutoff)
	//{
		////COLOR.rgb = vec3(0,0,0);
		//color.a = 0.0;
	//}
	for (int i = 0; i < fog_position_array_size; i++) 
	{
		color = rectanbleBorder(UV, color, fog_position_array[i].rg, fog_position_array[i].b, square_size, 0.0036);
	}
	COLOR = color;
}
"
